# 재사용: 상속보다 조립(?) - Inheritance Over Composition    
개인적으로는 그동안 봐왔던 문서나 책에 익숙해서 그런지 composition의 번역이 조립보다 합성에 익숙하고, 조립은 포함관계보다 뭔가 맞추는 행동이 먼저 떠올라 익숙하지 않다. 그래서 여기서 composition 이라고 영어 그대로 쓰고자 한다.      
앞서 상속에 대해서 `Is-a` 관계를 설명했는데, 이는 이번 장 책에서도 나와 있다. 그리고 상속은 재사용성을 살릴 수 있다고 소개했는데, 이 장에서 그 이야기를 한다. 여기서 함께 소개되는 `composition`은 뭔가를 가지고 있고 포함한다는 의미의 `Has-a` 에 해당한다. 상속보다 composition을 이야기하며 상속의 문제점을 소개한다. 엄밀히 말하면 상속의 문제점이라기 보다 상속을 잘못 사용했을 때 생기는 문제점이다. 따라서 상속을 용도에 맞게 잘 사용한다면 이러한 문제를 피하고 재사용성의 장점도 살릴 수 있다.     
## 상속을 잘못사용할 때 문제점     
책에서는 3가지를 소개하는데, 완전히 동의하기는 힘들다.      
물론 책에서 만든 예제처럼 상속을 잘못사용하면 클래스 개수가 늘어나고, 상위 클래스의 변화가 전파 되는 문제점이 있지만 이는 마지막에 나오는 상속의 오용처럼 상속을 오용할 때 생기는 문제라고 생각한다.      
앞서 의존성에 대해 설명할 때, 어떤 클래스가 의존하는 특정 클래스가 변화되면 그 클래스도 영향을 받는다. 그래서 상속이 아니더래도 의존성이 강할수록 특정 클래스를 변경하기 어려운 점이 있다. 책 뒤에 나올지 모르겠지만 약한 결합(loose coupling)과 강한 결합(tight coupling)의 차이점을 찾아보면 좋을 것 같다. 결합도가 강할수록 의존성이 커져서 변경하기 어려운 것이 단점이다. (https://en.wikipedia.org/wiki/Loose_coupling)       
### 단계가 많은 상속      
상위 클래스 변경의 어려움을 이야기할 때 상속을 세 번에 걸쳐 하고 있다. 이렇게 단계가 많으면 상위 클래스 변경이 어려울뿐 아니라, 코드를 읽기가 어렵다. 가장 하위에 있는 클래스에서 상위클래스의 메서드를 호출할 때, 이 메서드로부터 코드를 읽으려면 상위클래스로 가게 되고 이렇게 코드를 따라가다보면 어디 클래스에서 시작했는지 햇갈리기도 한다.    
### 기타 - 다중상속     
번외로 다중상속에 대해서 다뤄보겠다.(https://en.wikipedia.org/wiki/Multiple_inheritance) 2개이상의 부모클래스로 부터 상속받는 형태를 다중상속이라 하는데 다중상속으로 가면 구조가 복잡해지기도 하고, 이후 소개할 다이아몬드 문제가 생기기도 한다. C++ 과 같은 언어에서는 클래스의 다중상속을 지원해서, C++로 잘 구현된 코드를 보면 다형성과 Is-A 구조를 잘 살려서 쓰는 경우도 본적이 있다.    
#### 다이아몬드 문제     
위키피디아 다중상속 설명에는 다이아몬드 문제(https://en.wikipedia.org/wiki/Multiple_inheritance#The_diamond_problem)가 나온다. 해당 링크의 클래스 다이어그램을 보면 쉽게 알 수 있다.     
부모 A가 있는데, B와 C는 A를 상속받고 (여기까지는 일반적인 상속구조다) 그런데 B와 C를 다중상속받는 D가 생긴다. 다이아몬드 모양으로 서클이 생겨서 붙여진 이름이고, class D는 class A도 상속받는데, 이 class A는 B에서 오기도 했고, C에서 오기도 했다.      
문제는 D에서 A의 메서드를 사용하려고 하는데, 만약 B와 C가 둘다 해당 method를 오버라이드 했다면 B에 있는 method를 써야할까? C에 있는 method를 써야할까? 보통 다중상속을 지원하는 언어에서는 선택할 수 있게 문법을 제공하지만, 이는 구조를 어렵게 만드는 단점이 있다고 생각한다.     
#### 자바8부터 default method      
자바는 기본적으로 클래스 상속시 다중상속을 지원하지 않고, 인터페이스를 여러 개 구현하는 형태로 여러 인터페이스를 구현하는 형태는 가능하다. 자바8 이후부터는 인터페이스에 default method를 제공해서, method를 구현하지 않을 경우 default로 제공 하는 method가 있어서 기술적으로 다중상속 형태가 나타날 수 있긴 하다. default method는 개인적인 경험상, 한 번 사용한 인터페이스는 메서드를 추가하기 매우 어려운 문제가 있는데 이럴 때 유용하다. 예를들어 자바의 Collection interface는 자주 사용하는 ArrayList, HashSet, TreeSet 등이 구현하는 interface 인데, 자바8부터  Stream이 추가되면서 Collection으로 부터 Stream을 만들어줄 수 있는 stream default method (https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html#stream--) 가 추가되었다. 만약 이 stream method가 default method가 아닌 interface의 method로만 추가되었으면 어떻게 되었을까? 그러면 이미 Collection을 구현하는 수많은 ArrayList, HashSet 등에서 stream method를 일일이 구현해주어야 한다. 이럴 때 default로 기본 구현을 넣고자 한다면, default method가 유용하다.      

### 너무 많은 일을 하는 클래스     
클래스의 불필요한 증가 예제를 소개할 때, Storage를 상속받는 다양한 클래스를 소개한다. Is-A 관계에도 맞고 재사용성도 살릴 수 있는데 무엇이 문제일까?    
Encrypted, Compressed 같은 일을 하나씩 붙이다보면 다양한 조합이 많이 생긴다. 이러한 기능들은 인터페이스로 분리하여 붙여서 풀수도 있고, 각각의 기능을 클래스로 분리해서 책의 뒤의 예제처럼 포함관계로 할 수도 있다. 물론 인터페이스도 상속이긴 하지만 붙였다 떼어다 쓸수 있는 용도로 보면 적합할수도 있다고 생각한다. 이는 소프트웨어 요구사항과 앞으로의 확장성에 따라 다르다고 생각한다. 인터페이스로 붙인다면 Encrypted, Compressed 같은 기능을 클래스이름에 다 포함하지 말고 비즈니스로직에서 어떤 특정한 기능을 하는 Storage인데 그것이 Encrypted가 필요할수도 또는 Compressed 가 필요할 수도 있는 형태로 생각해볼 수 있을것 같다.      
그래서 클래스 하나가 최소한의 일만 하도록 쪼갠하다면 이러한 문제를 풀 수 있을 것 같다.    

## 정리     
상속과 Composition은 Is-a 관계와 Has-a 에 따라 적절히 판단하되, 가급적 재사용을 위한것이고 Is-a 관계보다 Has-a 관계에 좀 더 가깝다면 Composition을 먼저 고려하자.      
그리고 상속의 단계는 너무 깊어지면 복잡해질 수 있으니, 두 단계가 넘어간다면 정말 그것이 현재 구조에서 필요한지 생각해보면 좋을듯 하자.     
다중상속은 다이아몬드 문제가 있을 수 있으니 주의하고, interface의 경우 일반적으로 추가되는 method가 있으면 영향을 받는 클래스들은 구현을 다 해야하니, default method 같은 형태가 아니라면 초기 interface 설계에 주의를 많이 해야할 것이다.      
클래스의 정체성이 기능이 추가되면서 이상하게 늘어난다면 이를 쪼갤수 있는 방법을 고려하자. Encrypted + Compressed + 블라블라1ed + 블라블라2edStorage 처럼 늘어나는 것은 뭔가 설계를 잘못한게 아닐까 고민해봐야 할 것이다.      
이번에도 두서없이 생각나는대로 썼습니다.      
