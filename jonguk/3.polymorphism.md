# 다형성과 추상타입      
객체지향에서 다형성(Polymorphism)을 이야기할 때 이를 표현하는 방법 중 하나로 익숙하게 등장하는 개념 중 하나가 상속(Inheritance)이다. 책의 순서대로 상속부터 살펴보자.      

## 상속     
상속이라 하면 뭔가 물려받는다 생각할 수 있겠고, 아이들(Children)은 부모(Parents)를 닮듯 공통점이 있다는 점을 떠올릴 수 있다.    
사람에게서 사람이 태어나듯, 우리는 좀 더 포괄적이고 추상화된 개념으로 사람의 부모도 사람 사람의 아이도 사람이라고 부른다.    

### `IS-A` 관계로 본 상속       
상속으로 다형성을 표현하는 경우를 개인적으로 쉽게 표현했다고 생각한 개념이 `IS-A` 관계이다.     
위키피디아 (https://en.wikipedia.org/wiki/Is-a) 에 보면 OOP 개념으로 소개하고 있다.       
책에 있는 예제를 통해 상속에서 `IS-A`를 먼저 보자. `class LimitPriceCoupon extends Coupon` 이 있다. `LimitPriceCoupon`은 `Coupon`을 상속받는다. 그리고 `LimitPriceCoupon is coupon`이라고 할 수 있다. 즉, 상속관계를 표현할 때는 적어도 `상속받는대상은 상속하는 부모이다` 로 표현해도 어색하지 않은 관계여야 적절하다고 볼 수 있다.  
### 재사용성 및 접근지정자로 살펴본 캡슐화     
상속은 재사용성도 살릴수 있다. 부모에 있는 기능을 자식클래스는 상속받는다. 따라서 자식클래스에서는 부모의 기능을 사용할 수 있어서, 중복된 기능을 구현할 필요없이 그대로 물려받는다고 할 수 있어 재사용을 할 수 있다.     
책의 예제처럼 Java기준으로 `public` 또는 `protected`(같은 패키지나 상속관계) 접근지정자로 선언된 메서드나 필드라면 자식 클래스에서도 상속 받아 쓸 수 있다. `private`은 상속받을 수 없는 속성이고 선언된 클래스 안에서만(자식클래스도 당연히 접근안됨) 속성이다. 접근지정자를 지정인하면 같은 패키지에 있는 클래스에서만 접근할 수 있다. Java의 접근지정자 속성은 접근가능한 것과 접근못하는 것들을 이렇게 구분함으로써, 숨길 것은 숨기고 드러낼 것은 드러낼 수 있다. 이는 캡슐화에 있는 특징 중 하나인 은닉에 해당한다고 할 수 있다.     

## 추상화(Abstraction)      
개인적으로 추상화는 쉬운개념으로 묶는 것이라고 표현하고 싶다. 우리가 객체로 떠올릴 수 있는 간단한 단어가 일반적으로 추상화된 단어라고 할 수 있다. 우리는 `신발` 이라고 부르면 무엇인지 떠올릴 수 있어서 추상화된 단어로 쉽게 커뮤니케이션 한다. 위키피디아에 있는 사전적 정의처럼 `신발`을 부를 때마다 `발의 보호와 장식을 하기 위해서, 때로는 바닥에 미끄러지는 것을 방지하기 위한 것`을 신는다고 표현하면 매우 불편하고 이해하기도 어려울 것이다.        

### 어떻게 나눌것인가? (class? interface?)       
객체지향의 개념에 따라 만드려는 것들을 추상적인 객체로 나누었다면, 이제는 그 개념이 `concrete class`일지 `interface`일지 등을 어떻게 정하냐 하는 것이 남게 된다.      
`concrete class`은 구체화된 클래스이다. 실제 구현된 메서들이 다 들어가 있고, 구체적인 동작과 코드가 정의된 클래스로 생각할 수 있다.     
#### 구체적인것 -> 폭넓게 or 폭넓게 -> 구체적으로     
개인적으로는 먼저 내가 생각한 개념을 이름으로 표현한다. 책의 예제를 기준으로 처음 설계에 `FileReader`만 존재한다고 가정하면, 정말 폭넓게는 `Reader`를 먼저 떠올릴수도 있고, 구체적으로는 `FileReader` 같은 것을 떠올릴 수 있다. 그래서 개념을 떠올릴 때 좀 더 폭넓은 개념부터 구체적인 개념까지 나눠서 생각하고, 큰 개념에서 다른 개념이 파생되지 않을지 상상해보기도 한다. `FileDataReader` -> `DataReader` 그렇다면 `DataReader`에서 다른 `DataReader`가 나오지 않을까? 같은 접근이다.       
#### 인터페이스는?      
책의 예제에서 FileDataReader와 SocketDataReader는 `ByteSource`라는 인터페이스를 구현한다. FileDataReader 또는 SocketDataReader는 ByteSource라는 `is-A` 관계가 성립할까? 보았을 때 성립한다. 둘 다 `ByteSource`의 특징이 있다.     
그런데 이 특징은 두 `Reader`의 공통된 일부 기능일 뿐이다. 그리고 이 인터페이스가 빠졌을 때 이 기능만 두 Reader에서 뺄 수 있다. 즉 인터페이스는 어떤 기능을 붙였다 떼었다 할 수 있게 모양만 제공한다. 예를들어 책에서 `ByteSource`는 `public byte [] read()` 라는 1개의 메서드가 있다만 명시되어 있고, 이를 `implements`(구현)하는 쪽에서 이 기능을 구체적으로 구현할 수 있다. `ByteSource`는 인터페이스라서 `public byte [] read()`라는 형태의 기능이란 것이 전부이다.      
우리가 어떤 제품의 인터페이스가 어떻다 라고 이야기할 때, 구체적으로 구현되거나 제작된 원리는 다를지라도 사용자 입장에서 인터페이스가 같을 때 동일한 인터페이스라고 한다. 그래픽 유저 인터페이스(GUI)라고 하면 `OS`가 윈도우즈든 OSX 든 그래픽 기반의 인터페이스를 떠올리지, 터미널에서 문자로 입력하는 방식을 떠올리지는 않는다. 두 OS가 구체적인 면에서는 다르지만, 이런 그래픽을 GUI라고 부른다. 이렇듯 인터페이스는 어떤 공통적이고 부분적인 특징을 추상적으로 정의만 한다.       
처음에는 `class`에서 시작하지만 만들다 보면 이런 공통점이 보일 수 있다. 그러면 공통점을 단어로 표현하고 이를 인터페이스로 표현해서 빼본다면, 어떨 때 인터페이스를 쓸지 연습할 수 있다.      
책의 예제에서 처음에는 `FileDataReader`만 구현하지만, 요구사항이 추가되서 Socket에 대한 부분이 추가되고, 처음엔 중복코드에서 시작하지만 `FileDataReader`와 공통점이 보이는 `SocketDataReader`를 떠올렸다면 좋은 출발점이라고 생각한다.      
이 때 `public byte [] read()`와 같은 패턴이 `Reader`가 아닌 다른 클래스에서도 보이고 이를 공통점으로 뽑을 수 없을까 생각한다면 인터페이스를 떠올리기 위한 좋은 접근이라고 생각한다.    
이렇게 처음에는 추상적인 개념이나 구체적인 개념 등을 나눠서 시작해서 `isA`인지 관계를 정의하고 여기서 공통점을 찾아내서 나누는 등의 작업을 하다보면, 각각의 이름과 범위를 나누고 interface와 concreate class 를 나눌 수 있다.      
그리고 하나의 클래스가 너무 많은 일을 한다면 개념을 나눠서 클래스의 크기도 작게 할 수 있다고 생각한다.       

### 인터페이스는 약속이며, 테스트를 위해서 좋다.        
인터페이스는 서로간의 약속이기도 하다. 책의 뒤에서 나오지만, 상대방이 무엇인가를 구현하기 전에 이를 테스트해보기 위해 Mock객체를 만드는 방법이 나온다. 여기서 mock을 이용해 테스트 코드를 작성하는 방법도 배울 수 있다. Mock객체를 만드려면 그것의 인터페이스가 있어야 하고, 상대방이 아직 구현을 안했어도 해당 인터페이스가 있어야 그대로 구현을 해서 mock테스트로 테스트 통과하는 코드를 작성했을 때 나중에 상대방이 구현한 클래스를 넣을 수 있다.      
즉, 미리 인터페이스를 정의하고 그것으로 mock을 만들어 테스트하고 상대방도 그 약속대로 만드는 면에서 인터페이스는 협업할 때 약속의 의미도 있다고 생각한다.      
참고로 이런 부서간의 계약(contract)를 하고 테스트하는 방법을 마틴파울러 사이트에 https://martinfowler.com/bliki/ContractTest.html 라고 소개해놓은 글이 있으니 관심있으면 참고하면 좋을 것 같다. 아직 써보진 않았지만, 바로 다음에 소개할 테스트 피라미드 주제의 article에서 소개된 contract test 툴로는 pact (https://docs.pact.io/) 라는 것이 있다.     

### 테스트     
책에서 인터페이스가 테스트하는데 도움이 되는 내용이 나온다. 객체지향적인 설계가 테스트하기 쉽게 만드는 면도 있으니 좀 더 파볼만한 주제라고 생각한다.       
테스트에 대해서는 문득 생각이 든게 마틴파울러 테스트 피라미드에 대한 글이 있다. 좋은 글이니 시간이 될 때 참고하면 좋을 것 같다. https://martinfowler.com/articles/practical-test-pyramid.html       
피라미드의 아랫쪽으로 갈수록 테스트 만드는 속도는 빠르고 대신 실제 테스트 환경과 멀어진다.     
개인적인 경험으로 피라미드 모든 레벨의 테스트가 다 있고 꼼꼼하게 될수록 소프트웨어 퀄리티는 높아지겠지만, 가성비를 생각하면 우리의 시간은 제한되어 있다. 그래서 Http API를 예로 최소한으로 생각하면, 각 비즈니스로직을 테스트하기 위한 Unit Test (필요에 따라 mock을 사용하여 test가 필요할 수도 있음)와 인테그레이션 테스트로 각 api entry point에서 주어진 request에서 기대하는 response를 확인 하는 정도는 있으면 좋은 것 같다. 그리고 테스트하기 쉬운 것부터 테스트 코드를 작성하더래도, 비즈니스 로직 유닛테스트의 테스트 커버리지는 되도록 높게 커버될 수 있게 노력하는 연습도 필요할 것 같다. Sonar Qube같은 툴로 테스트커버리지를 측정할 수도 있으니 도움이 될 것이라 생각한다.     
그런 면에서 책에도 소개되었지만 TDD는 테스트를 먼저 만든다는 점에서 정말 좋은 방법이라고 생각한다. 켄트백에 의해 워낙 유명하게 알려졌으니 켄트백의 테스트주도개발 책은 꼭 읽어보면 좋다고 생각한다. 학생 때 그 책을 처음 읽었을 때 너무 신세계였고 감명받았다. 테스트를 먼저 작성함으로써 테스트가 있는 것을 보장하고, 테스트가 통과하는 코드를 작성하는 습관을 들이는 것은 개발자로서 좋은 습관이라고 생각한다.    
