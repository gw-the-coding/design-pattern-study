# 함께 보기로한 책   
개발자가 반드시 정복해야 할 객체 지향과 디자인 패턴 - 최범균 지음   
시중의 책 중 쉽게 설명된 편이고, 익숙한 예제도 제공하고 객체지향 등 개념에 대해 잘 설명되어 있다.      
이 책을 읽어보고 내가 이해한 개념으로 객체지향부터 간단히 정리해보고 한다.     
# 객체지향    
## 객체지향과 절차지향   
객체지향과 절차지향의 차이점에 대해 나오고, 절차지향대로 코드를 작성하고 코드가 복잡해졌을 때 문제점, 이를 객체지향으로 해결한 예제를 설명한다. 프로시저가 다른 프로시저를 호출하며 프로시저 위주로 프로그래밍을 한 방식과 객체중심의 객체지향을 비교하는데 여기서는 객체지향의 개념을 이해하는게 중요하므로, 개인적으로는 객체지향과 객체에 대한 고려를 하지 않은 비객체지향 정도로 나눠서 보는게 편하긴하다.     
## 객체(Object)    
데이터와 프로시저로 구성된다.       
내 생각에는 객체라고 하면 우리가 일상생활에서 명사로 부르는 사물을 떠올릴 수 있다. Object의 뜻을 찾아보면 사물이란 뜻도 있다.      
`책`, `자동차`, `사용자`, `영화`, `TV`, `장농` 등 다양한 사물을 객체로 표현할 수 있다. 요구사항에 따라 객체가 무엇이 있는지 떠올려보자.      
### 클래스와 인터페이스     
인터페이스는 구현이 없이 기능만 명세하는 것이다. 흔히 우리는 "어떤 인터페이스를 가졌다" 라고 설명할 때 추상적인 기준에서 설명을 한다. 그리고 그것을 구체적으로 어떻게 표현할지는 인터페이스의 규칙에 맞는다면 동일한 인터페이스로 인식한다. 그리고 이러한 인터페이스 규칙에 맞게 구현된 실체를 클래스라고 말할 수 있다.      
### 메시지    
객체지향의 핵심은 메시지 전달이다. 하나의 객체에서 다른 객체의 특정 메서드를 호출할 때, 메시지를 전달한다고 할 수 있다. 어떤 객체에게 어떤 메시지를 전달할 수 있고, 각 객체의 메시지전달을 어떤 순서대로 할지 구현하는 것이 객체지향이라고 이해가 된다.      
### 객체를 떠올릴 때, 나는 이렇게 생각한다.     
프로시저는 이 사물이 할 수 있는 행위라고 할 수 있다. 프로그래밍에서는 함수 형태로 표현이 되겠고, 능동적 행동뿐 아니라 다양한 상태나 수동적 표현이 가능할 수 있다고 본다. 예를들어 사용자(User) 있으면 `user.isVip()` 처럼 vip인지 아닌지 확인하는 메서드도 있을 수 있다.   
데이터는 이 사물이 담고 있는 값이라고 할 수 있다. 프로시저를 수행하는데 필요한 값이라고 할 수 있다. 예를들어 이 유저가 등급이 VIP인지 알 수 있도록 등급을 나타내는 role 이란 변수를 User 클래스 안에 정의할 수 있다.       
## 객체의 책임과 크기 & 의존     
### 의존     
객체는 다른 객체에 의존할 수 있다. 먼저 요구사항을 바탕으로 객체들을 정의했다면, 어떤 객체가 어떤 객체에 의존하는지 관계를 정의하는 것이 필요하다.     
만약에 한 객체가 너무 많은 일을 해버려서 하나의 단어로 표현을 못한다면, 표현가능한 각각의 이름으로 나눠서 이렇게 쪼개진 객체가 다른 객체를 의존하게 할 수 있다.    
### 객체의 책임과 크기       
이렇게 객체의 기능을 작게 쪼개면, 나중에 특정 객체의 기능을 재사용하기도 쉽고, 객체의 이름만 보고 어떤 일을 할지 생각하기도 쉽다.   
예를들어 Book이란 class를 정의해서 책에 필요한 부분들을 정의했는데, 이 책은 우리가 일반적으로 책이라고 생각하는 종이책을 기준으로 설계되었다. 그런데 책에 전자책기능이 필요하다고 요구사항이 들어왔다고 하면 어떻게 해야할까? Book이란 클래스에 종이책과 전자책에 공통적인 부분이라면 상관없겠지만, 전자책에만 있는 밝기조절이나 on/off 기능을 이 Book 클래스에 추가한다면 동작은 하겠지만, 기존 종이책 기능에 제공하던 기능에도 on/off 기능이 있는 어색함이 발생할 것이다. 이렇게되면 나중에 유지보수하는 사람도 Book class를 보고 큰 혼란을 겪게 될 것이다. Book에 상태값을 둬서 전자책인지 종이책인지 구분을 둔다고 해도 여전히 종이책에는 필요없는 기능이 있는 것이 마찬가지다.     
간단히 종이책, 전자책 class를 별개의 객체로 정의하고 나중에 나오게 될 상속이란 걸 이용해서 공통된 부분은 Book으로 상속 받으면 된다. 적어도 상속이란 개념을 몰라도 전자책에 있는 기능이 Book에 있는 것은 어색하고 두 개는 공통이 있지만 별개의 객체라는 것 정도는 알 수 있다.    
순환참조로 인한 의존도 나오는데, 경험상 이는 잘못된 설계의 신호이다. 왜냐하면 이 책에도 나와 있지만 어떤 객체에 의존하면 그 객체의 수정이 의존하는 객체도 영향을 주는데, 서로 영향을 주면 하나의 객체 수정이 자기자신과 이 객체를 의존하는 객체에도 영향을 주기 때문이다.      
a객체가 결과적으로 c객체에 의존적인데, c객체도 a객체가 필요하다면 서로가 의존적인 부분 중 공통된 부분을 분리하는 식으로 순환참조를 끊어준 기억도 있다.      
## 캡슐화     
이 책에서 캡슐화의 은닉에 대해서 자세히 소개가 안되어 있는거 같아 위키피디아를 찾아보았다.(
https://ko.wikipedia.org/wiki/%EC%BA%A1%EC%8A%90%ED%99%94        
) 캡슐화는 1) 객체의 속성과 행위를 묶고, 2) 실제 구현내용 일부를 외부에 감추어 은닉한다.     
초반이라 그런지 책에서는 1) 에 해당하는 속성과 행위를 묶는데 집중해 설명한다. 은닉 같은 경우도 불필요한 기능을 외부에 숨기는 것이다. 너무 많은 기능을 하는 경우 객체가 복잡해지기 때문이다.     
자세한 구현을 직접 표현하지 말고 객체의 프로시저로 정의해서 추상화된 표현으로 감춘다고 생각하면 될듯 하다.       
예를들어 아까 전자책과 종이책의 예제에서 보면 책의 공통적인 부분만 책의 특성을 정의한다면 전자책이든 종이책이든 상관없이 책의 공통된 기능만 쉽게 사용할 수 있다. 이는 뒤에 나올 다형성에 설명될 것으로 예상한다. 만약에 특정 객체에 드러나지 말아야할 기능이 드러난다면 객체를 잘못나눈것이거나 은닉을 적절하지 하지 못한 것이라 볼 수 있다고 생각한다.      

두가지 법칙을 설명하고 있다.      
### Tell Don't Ask     
묻지 말고 기능을 실행해달라고 말한다는데, 이 문장만 읽으면 어렵다.    
어떤 기능을 해달라고 요청만 하면, 알아서 된다는 식이다. 어떤 객체에 어떤 기능을 해달라고 해야할지 생각하고, 그것의 실제 구현은 그 메서드를 구현할 때 하면 된다.      
### 데미테르의 법칙    
객체는 3가지가 있을 수 있다. 클래스에 필드로 정의된 객체, 클래스에 메서드를 구현할 때 파라미터로 전달받은 객체, 그리고 그 메서드 안에서 생성한 객체이다. 이 3개의 객체에 직접 접근가능한 메서드만 호출하란 것이 데미테르의 법칙이라고 설명한다.      
메서드 체이닝 같이 member.getDate().getTime() 처럼 member에 있는 메서드를 직접 호출하지 않고, getDate()에 있는 것을 가져와서 호출한 체이닝한 예제를 들고 있는데, 단지 member한테 하나의 메서드로 무엇인가 해달라고 요청하면 된다는 법칙이다. 이렇게 하면 member가 date를 가지고 있다는 것에 대해서 모르고, 단지 memeber.getTimeOnly() (date다음에 time인데 DateTime도 아니고 네이밍이 급 어려워진다 ㅠ date를 get하고 time을 얻어야 하는 구조가 좀 이상하다) 처럼 하나의 메서드만 호출해서 한다는 것인데, 이것도 케바케인것 같다. 검색을 해보면 이 원칙을 다 지키다보면 메서드들이 엄청 늘어나는 건 단점으로 언급되어 있다. 캡슐화를 초기에 연습하기 좋은 규칙이긴하지만, 규칙이 깨졌을 때 생기는 장점과 단점을 구분하는 눈이 생긴다면 캡슐화의 장점을 잘 살릴 수 있지 않을까 생각한다.     

# 정리     
일단 복잡하고 중복이 생기더래도 많이 코딩을 해보는 것도 중요한거 같다. 그러다보면 중복되는 패턴이나 비효율적인 부분이 떠올를 것이고, 이 때 공부한 디자인패턴이나 객체지향 법칙들이 도움이 될것이라 생각한다.     
처음에 객체지향을 시작할 때는 객체단위로 나눠서 요구사항을 서술하고, 이를 클래스나 인터페이스 형태로 옮겨보는 것도 도움이 된다고 생각한다. 나중에 테스트코드를 짜는 것에 익숙하다면 이를 테스트코드로 작성하여 테스트하기 쉽게 만드는 것도 필요하다고 생각한다.      
일단은 비 객체지향적으로 작성한 코드를 작성해보고 어떻게 객체지향처럼 바꿀 수 있을지 서로 의견을 나눠보는 것도 좋지 않을까 생각한다.           
